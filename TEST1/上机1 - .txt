（1）P45第3题//顺序表逆置
题目要求：以顺序表作为存储结构，写一个实现线性表的就地(即使用尽可能少的附加空间，空间复杂度为O(1))逆置的算法，在原表的存储空间内将线性表(a1，a2,.. .,an)逆置为(an,.. .,a2,a1)。

#include<stdio.h>
#include<malloc.h>
typedef char datatype;
#define  maxsize  1024
typedef struct
{ datatype data[maxsize];
  int last;
}sequenlist;
sequenlist* create( );
void print(sequenlist*);
void invert(sequenlist*);

int main(  )
{
  sequenlist*L;
  printf("***************请创建顺序表，'*'结束输入*****************\n");
  L=create( );//建立顺序表
  printf("****************输出顺序表******************\n");
  print(L);//输出顺序表
  invert(L);//调用顺序表逆值的函数
  printf("************输出逆置后的顺序表**************\n");
  print(L);//输出顺序表
  return 0;

}

//建立顺序表,'*'结束输入

sequenlist* create()

{

	




}



//输出顺序表

void print(sequenlist*L)

{

	



}


void invert(sequenlist* L) 
//顺序表逆置

{




}//时间复杂度为O(n)


测试用例1（*结束输入）: 

输入： abcdef* 

输出：fedcba


测试用例2: 

输入：*

输出：提示：该表为空表，无需逆置




（2）P45第3题//单链表逆置
题目要求：以单链表作为存储结构，各写一个实现线性表的就地(即使用尽可能少的附加空间)逆置的算法，在原表的存储空间内将线性表(a1，a2,.. .,an)逆置为(an,.. .,a2,a1)。
要求：时间复杂度为O(n),空间复杂度为O(1)

#include<malloc.h>
#include<stdio.h>
//单链表结构类型定义
typedef int datatype;
typedef struct node
{
   datatype data;
   struct node *next;
}linklist;
linklist* create( );
void print(linklist *);
void invert(linklist*);
int main( )
{
    linklist * head;
    printf("***************请创建链表,-1结束输入*****************\n");
    head=create( );//构建单链表
    printf("***************输出原链表*****************\n");
    print(head);//输出单链表
    invert(head);//调用单链表逆置的函数
    printf("************输出逆置后的链表**************\n");
    print(head);//输出单链表
    return 0;
}


//采用尾插法建立具有头结点的单链表
linklist* create( )
{
	



}

//输出单链表
void print(linklist *head)
{
	




}
//链表逆置，只能通过修改指针的方式，不能通过修改元素值的方法实现
void  invert(linklist* head)

{
	



}//时间复杂度为O(n)


测试用例1: 

输入：1->3->5->7->2->15->20->6->NULL 

输出：6->20->15->2->7->5->3->1->NULL 


测试用例2：

输入：11->23->5->57->2->35->20->NULL 

输出：20->35->2->57->5->23->11->NULL 


测试用例3（空表测试）: 

输入：输入结束值（如-1结束），生成空表

输出：提示：该表为空表，无需逆置

 
（3）题目要求：删除递增顺序表中的所有重复结点，重复结点只保留1个。要求：时间复杂度为O(n),空间复杂度为O(1)。
#include "stdafx.h"

#include<stdio.h>

#include<malloc.h>

typedef int datatype;

#define  maxsize  1024

typedef struct

{  datatype data[maxsize];

   int last;

}sequenlist;

sequenlist* create();
void print(sequenlist*);
void  purge(sequenlist *);


int main()

{ sequenlist*L;
  char x;
  L = create();//建立顺序表
  printf("删除之前的顺序表为：");
  print(L);//输出顺序表
  purge(L);//调用顺序表去重函数
  printf("去重之后的顺序表为：");
  print(L);//输出顺序表
  return 0;

}



//建立顺序表

sequenlist* create()

{

	



}



//输出顺序表

void print(sequenlist*L)

{

	


}



void  purge(sequenlist *L)
{
	




}//删除有序顺序表中重复元素，时间复杂度O(n)



测试用例1: 

输入：1 1 1 3 3 5 6 6 6 6 8 8 15 15 15 15 15

输出：1 3 5 6 8 15


测试用例2：

输入：1 2 2 3 3 3 6 6 6 6 8 8 15 16 16 20

输出：1 2 3 6 8 15 16 20


测试用例3：

输入：1 2 3 3 3 3 3

输出：1 2 3 

测试用例4：

输入： 3 3 3 3 3 6 

输出：3 6


测试用例5（空表测试）: 

输入：输入结束值（如-1结束），生成空表

输出：提示：该表为空表，无需去重

 
（4）题目要求：删除一个带头结点的递增单链表中的所有重复结点，重复结点只保留1个。要求：时间复杂度为O(n)，空间复杂度为O(1)。

#include "stdafx.h"

#include<malloc.h>
#include<stdio.h>
//单链表结构类型定义
typedef int datatype;
typedef struct node
{  datatype data;
   struct node *next;
}linklist;
linklist* create();
void print(linklist *);
void DelRedundant(linklist *);
void main()
{
	linklist*head;
	head = create();//构建递增单链表
	printf("****************原递增链表如下****************\n");
	print(head);//输出单链表
	DelRedundant(head);//调用单链表去重的函数
	printf("****************去重后的链表如下****************\n");
	print(head);//输出单链表
}

//采用尾插法建立具有头结点的单链表
linklist* create( )
{
	



}

//输出单链表
void print(linklist *head)
{
	




}




//单链表去重
void  DelRedundant(linklist *head)
{
	




	
}//时间复杂度为O(n)，空间复杂度O(1)




测试用例1: 

输入链表显示：1->1->1->3->3->5->6->6->6->6->8->8->15->15->15->15->15->NULL

去重链表显示：1->3->5->6->8->15->NULL


测试用例2：

输入链表显示：1->2->2->3->3->3->6->6->6->6->8->8->15->16->16->20->NULL

去重链表显示：1->2->3->6->8->15->16->20->NULL


测试用例3：

输入链表显示：1->2->3->3->3->3->3->NULL

去重链表显示：1->2->3->NULL 

测试用例4：

输入链表显示： 3->3->3->3->3->6->NULL 

去重链表显示：3->6->NULL


测试用例5（空表测试）: 

输入：输入结束值（如-1结束），生成空表

输出：提示：该表为空表，无需去重


 
（5） //多项式求和运算：设单链表A和B分别存储不同的多项式，要求完成多项式的求和运算，求和结果存放在A表中（备注：B表清空）。

#include "stdafx.h"
#include<malloc.h>
#include<stdio.h>
//多项式单链表结构类型定义
typedef struct node
{
	int coef;
	int exp;
	struct node *next;
}linklist;
linklist* create( );
void print(linklist *);
void  SumofPoly(linklist *, linklist *);
void main( )
{
	linklist*A, *B;
	printf("**************请输入原多项式A链表为*****************\n");
	A = create( );
	printf("**************请输入原多项式B链表为*****************\n");
	B = create( );
	printf("**************显示原多项式A链表为*****************\n");
	print(A);
	printf("**************显示原多项式B链表为*****************\n");
	print(B);
	SumofPoly(A, B);//调用多项式求和的函数
	printf("**************显示求和运算之后的多项式A链表为*****************\n");
	print(A);


}

测试用例1（注：输出格式不限，无须按示例格式显示）：

（1）A(x)=7+3x+9x^8+5x^17+2x^20;

     B(x)=8x+22x^7-9x^8-4x^18+30x^25+10x^35+19x^55;

    结果：
     A(x)= 7+11x+22x^7+5x^17-4x^18+2x^20+30x^25+10x^35+19x^55;
     B表空


测试用例2：

（2）A(x)=19+3x+72x^7+6x^17+2x^28+10x^35+19x^55;

     B(x)=8x^4+22x^7-6x^17-2x^28

    结果：
    A(x)= 19+3x+8x^4+94x^7+10x^35+19x^55;
    B表空


测试用例3：

（3）A(x)=23+3x+7x^6+16x^18+2x^23+10x^32; 
     B(x)=-23-3x+17x^6-16x^18-2x^23-10x^32;

    结果：
     A(x)= 24x^6;
     B表空


测试用例4：

（4）A(x)=23+3x+7x^6+16x^18+2x^23+10x^32;
     B(x)= 6x^12+16x^38-2x^42-10x^62;
     结果：
     A(x)= 23+3x+7x^6+6x^12+16x^18+2x^23+10x^32+16x^38-2x^42-10x^62;
     B表空


（6）P45第6题// 归并递减
题目要求：设A和B是两个递增有序的单链表。试编写一个算法将A和B归并成一个按元素值递减有序的单链表C，并要求辅助空间为O(1)，C表的头结点可另辟空间。分析算法的时间复杂度。

#include<malloc.h>
#include<stdio.h>
//单链表结构类型定义
typedef int datatype;
typedef struct node
{
	datatype data;
	struct node *next;
}linklist;

linklist* create();
void print(linklist *);
linklist* mergelist(linklist*, linklist *);
void insert(linklist*,linklist*);
int  main(void)
{	linklist*La,*Lb,*Lc;
printf("****************请创建链表La******************\n");
	La=create();
printf("****************请创建链表Lb******************\n");
	Lb=create();
printf("***************输出链表La*****************\n");
	print(La);
printf("***************输出链表Lb*****************\n");
	print(Lb);
	Lc=mergelist(La,Lb);
printf("*****输出显示La表和Lb表归并递减后的链表Lc*****\n");
	print(Lc);
return 0;

}

//采用尾插法建立具有头结点的单链表
linklist* create( )
{
	



}

//输出单链表
void print(linklist *head)
{
	




}

linklist* mergelist(linklist*La, linklist *Lb)

{



}//归并递减，时间复杂度?，空间复杂度O(1)


(7)设计一个算法判断链表是否存在环，要求算法的时间复杂度为O(n),空间复杂度为O(1)。

#include "stdafx.h"
#include<malloc.h>
#include<stdio.h>
//单链表结构类型定义
typedef char datatype;
typedef struct node
{  datatype data;
   struct node *next;
}linklist;
linklist* create();
void print(linklist *);
int  judgecycle(linklist*);
void Yescircle(linklist *);
void main()
{  int x = 0;
   int i;
   linklist*head;
   printf("生成一个链表长度>5的链表，遇到'*'结束：");
   head = create();//构建单链表
   printf("***********显示原来的链表为：***************\n");
   print(head);
   printf("\n 输入i的值，i为偶数调用生成环函数，i为奇数则不调用：");
   scanf_s("%d", &i);
   if (i % 2 == 0)	
       Yescircle(head);//生成环函数
   x = judgecycle(head);//调用判断环是否存在的函数
   if (x == 1)printf("\n ***********判断结果该链表存在环\n");
   else printf("\n ***********该链表不存在环\n");	

}

//采用尾插法建立具有头结点的单链表
linklist* create()
{
	linklist* head;
	char ch;
	linklist *s, *r;
	head = (linklist*)malloc(sizeof(linklist));
	r = head;
	
	while ((ch = getchar()) != '*')
	{
		s = (linklist*)malloc(sizeof(linklist));
		s->data = ch;
		r->next = s;
		r = s;
	}
	r->next = NULL;
	return head;
}

//输出单链表
void  print(linklist *head)
{
	linklist*p = head->next;
	while (p != NULL)
	{
		printf("%2c", p->data);
		p = p->next;
	}
	printf("\n");
}


int judgecycle(linklist *head)
{
	


}//判断是否存在环

void Yescircle(linklist * head)
{
	
}//针对普通单链表生成环


（8） 寻找长度大于3的单链表的中间结点，返回该结点的值。（要求：只能遍历一次单链表，时间复杂度O(n)）



测试用例1：

输入：1,5,3,22,36,78,18,20

输出：36

测试用例2：

输入：1,5,3,22,35,78,18,20,90

输出：35

测试用例3：

输入：8

输出：8


